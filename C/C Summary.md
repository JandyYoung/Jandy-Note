# 关键字

| 关键字 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| auto   | 当前变量的作用域为当前函数或代码段的局部变量，当前变量在内存栈中分配。(编译器默认缺省情况下所有变量都是auto) |
| char | 字符串数据类型，32位机中1字节大小 |
| short | 短整型数据类型，32位机中2字节大小 |
| int | 整型数据类型，32位机中4字节大小 |
| long | 长整型数据类型，32位机中4字节大小 |
| float | 单精度型浮点数，32位机中4字节大小 |
| double | 双精度型浮点数，32位机中4字节大小 |
| signed | 声明的整型变量为有符号类型，最高位为1表示负数，最高位为0表示正数，但是其本质还是大于0的数 |
| unsigned | 声明的整型变量为无符号类型 |
| struct | 声明结构体变量 |
| union | 声明联合数据类型 |
| enum | 声明枚举类型 |
| static | 修饰变量，修饰全局变量，其作用域为该变量定义的文件中；修饰局部变量则该变量不会因为函数的结束而结束；修饰的变量都存储在内存的静态区。修饰函数则表明该函数为静态函数，只能在函数定义所在的文件调用。|
| switch | 用于开关语句 |
| case | 开关语句分支 |
| default | 开关语句中的其他分支 |
| break | 跳出当前循环 |
| register | 声明寄存器变量 |
| const | 声明只读变量 |
| volatile | 表明修饰的变量不可以被编译器或者优化 |
| typedef | 用以给数据类型取别名 |
| extern | 声明变量是在其他文件中定义 |
| return | 子程序返回语句，用来终止一个函数并返回后面的值 |
| void | 声明函数无返回值或无参数，声明空类型指针 |
| continue | 结束当前循环，开始下一轮循环 |
| do | 循环语句的循环体 |
| while | 循环语句的循环条件 |
| if | 条件语句 |
| else | 条件语句否定分支 |
| for | 一种循环语句 |
| goto | 无条件跳转语句 |
| sizeof | 获取数据在内存中占用的存储空间(单位：字节) |

1. 声明和定义的区别:

   定义：创建一个对象，向这个对象分配一块内存并取变量名或者对象名。
   声明：告诉编译器，该变量已经与内存绑定或者即将绑定。
> 变量名与内存地址绑定，且变量不能重复定义；声明可以使用很多次；定义分配内存，声明不分配内存。

2. `bool` 量中 `FLASE` 的值为0，`TRUE` 的值不一定为1；`bool` 变量一般初始化为`FLASE`。
3. `register` 将变量尽可能存在CPU内部寄存器，但不一定能够存在CPU寄存器，编译器对 `register` 修饰的变量访问速度很快。可以将频繁操作的变量放入寄存器中，且不能通过&进行取地址操作，变量长度要小于寄存器长度。
4. 计算变量时可以省略括号，计算类型时不可以省略
5. 在if判断语句中，当需要判断括号内的表达式的值是否为真或者为假时，不要写成 `if (... == TRUE)`或者 `if (... == FLASE)`，因为`FLASE` 和 `TRUE` 的值不一定为0或者为1，判断为真可以写成 `if（...）`，判断为假可以写为  `if (!(...))`。
6. `float` ：在32位机中占用4位，总共32个bit = 符号位S(31)+指数位E(30-23)+小数M(22-0)； 

浮点数 = (1 + M) * 2^(E-127)，符号位(S)表示正负，S为1表示负数，S为0表示正数；指数位E-127表示向左移动多少位，当其为负数时表示向右移动；小数M表示小数点的数据(由于整数部分一定为1所以省略整数部分)。
例如：8.25转换为二进制为1000.01，那么其数据为1.00001 * 2^3，则指数位E = 127+3 = 130，小数部分为00001，则浮点数即为0 10000010 00001000000000000000000

>1. 小数部分转二进制：小数部分乘以2，取整数部分，剩下的小数部分继续乘以2，直至小数部分为0。
>如0.5 * 2 = 1，因此0.5二进制为0.1；如0.125 * 2 = 0.25，0.25 * 2 = 0.5，0.5 * 2 = 1，因此0.125二进制为0.001；如0.3 * 2 =  0.6，0.6 * 2 = 1.2，0.2 * 2 = 0.4，0.4 * 2 = 0.8，0.8 * 2 = 1.6，0.6 * 2 = 1.2，0.2 * 2 = 0.4，0.4 * 2 = 0.8，0.8 * 2 = 1.6....根据计算精度进行保留，0.3二进制为0.010011001....
>2. float的精度在二进制中为23位，但是转换为10进制后精度只有小数点后6-7位。
>3. 浮点数在计算中不能使用 `==` 来对其进行精确比较
>4. 由于浮点数自身有误差，因此在进行累加操作之后误差也会累加；较大数和较小数进行进行加减运算时可能会与较大数

```
    #include <stdio.h>

    int main(void)
    {
      float i = 3.14159265;
      float j = 3.14159266;

      if (i == j)
      {
        printf("i == j.\n");
      }
      else
      {
        printf("i != j.\n");
      }

      return 0;
    }
    
gcc test.c -o test
i == j.
```

6. `double`：在32位机中占用8位，总共64个bit = 符号位S(63)+指数位E(62-52)+小数M(51-0)。
>浮点数变量不能在 `switch` 中进行判断比较。
>
>7.  NULL和0不要一起比较，因为虽然NULL实质为0但是意义不一样。
8. 不同数据之间转换之间需要注意精度扩展问题和数据对齐问题。
9. `void` 表示空类型，用于声明函数无返回值和函数参数的限定，禁止用 `void` 定义一个变量；但是 `void*` 可以指向任何类型的数据，且其他类型的指针向 `void*` 定义的指针可以直接通过无强制转换的进行赋值，反过来不行。
10.  `void*` 指针不能对其进行运算操作，但是当对其强制类型转换后就可以进行运算。
11. `return` 用来终止一个函数并返回后面的值，返回0表示函数正确，也可以返回具体的值，也可以返回表达式（表达式需要用括号哦括起来）；但是不可以返回栈地址或者指针，因为变量在函数中使用完后会被销毁。
12. `const` 修饰的值不能改变，譬如 `const int a = 10;` 定义后 `a` 的值不能改变，且可以放在数据类型的前面和后面。`const` 在修饰指针时有以下情况：

```
    const int *p;//const 修饰的是 *p，那么 *p 是指向的对象不可变;
    int const *p;//const 修饰的是 *p，那么 *p 是指向的对象不可变;
    int* const p;//const 修饰的是 p，那么 p 指针不可变;
    const int* const p;//const修饰了 *p 和 p，那么 *p 和 p都不可变;
```

`const` 可以修饰函数中的形参和函数的返回值，如 `const int fun(const int i);`

13. 编译器优化问题：当编译器发现两次对一个变量读取数据，但是没有对该变量进行操作，那么编译器将会直接把上次读到的数据进行读取而不是从该变量中进行读取，以此提高便以效率；

```
int i = 10;
int j = i;//编译器会从i的内存地址中读取数据赋值给j；
int k = i;//编译器不会从i的内存地址中读取数据；
```

如果该变量为实时变化的数据如中断或者端口数据，那么后续操作将不会读取到真正的值，因此可以在该变量前用 `volatile` 进行声明。（如果盲目的使用 `volatile` 将会导致代码运行效率下降）
14. 结构体内存大小 = 成员所占内存大小之和，空结构体内存大小为1bit。
15. `union` 和 `struct` 区别：`union` 中所有的元素都是同一个地址，即他的内存大小就是最大长度的数据成员；`struct` 的元素都是相对独立的，即每个元素都会占用一定的内存空间；也就是说同一时刻 `union` 中只存放一个元素，而 `struct` 中存放了全部元素。
16. 




参考:
《C语言深度解刨》